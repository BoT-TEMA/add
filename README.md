# Отчет по задаче "Ближайший меньший справа"

### Код можно найти [здесь](/near_min_right.cpp)

## Теоретическая часть

### Постановка задачи
Для каждого элемента массива необходимо найти индекс ближайшего элемента справа, который меньше текущего. Если такого элемента нет, следует вернуть Х.

### Идея решения
Алгоритм использует стек для хранения элементов, для которых еще не найден ближайший меньший справа. Основные принципы:
1. Проход по массиву слева направо
2. Для каждого текущего элемента:
   - Пока вершина стека больше текущего элемента, извлекаем элементы из стека (текущий элемент является для них ответом)
   - Добавляем текущий элемент в стек
3. В стеке всегда поддерживается возрастающая последовательность

### Реализация
```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

vector<int> nearestSmallerRight(const vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1);
    stack<pair<int, int>> st;
    
    for (int i = 0; i < n; ++i) {
        while (!st.empty() && st.top().first > nums[i]) {
            result[st.top().second] = i;
            st.pop();
        }
        st.push({nums[i], i});
    }
    return result;
}
```


## Тестирование программы

### **Тест 1**(из разбора): <br>
![Первый тест](https://github.com/BoT-TEMA/add/blob/main/Screenshot%202025-06-05%20at%2000.04.56.png)
<br>

### **Тест 2**: <br>
![Первый тест](https://github.com/BoT-TEMA/add/blob/main/Screenshot%202025-06-05%20at%2000.01.32.png)
<br>

### **Тест 3**: <br>
![Второй тест](https://github.com/BoT-TEMA/add/blob/main/Screenshot%202025-06-05%20at%2000.01.48.png)
<br>

### **Тест 4**: <br>
![Третий тест](https://github.com/BoT-TEMA/add/blob/main/Screenshot%202025-06-05%20at%2000.01.19.png)
<br>




### Анализ результатов
Во всех тестах программа корректно находит индексы ближайших меньших элементов справа. В случаях, когда такого элемента нет (последний элемент или элементы в возрастающем порядке), возвращается Х.

## Выводы

1. Алгоритм успешно решает задачу поиска ближайшего меньшего справа за O(n) времени и O(n) дополнительной памяти
2. Реализация соответствует подходу, разобранному в видео-разборе задачи
3. Тестирование подтвердило корректность работы алгоритма для различных случаев:
   - Убывающие последовательности
   - Возрастающие последовательности
   - Случайные последовательности
   - Последовательности с повторяющимися элементами

Программа демонстрирует эффективное решение задачи с использованием стека, что позволяет достичь линейной временной сложности.
