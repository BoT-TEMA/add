# Отчет по задаче "Ближайший меньший справа"

## Теоретическая часть

### Постановка задачи
Для каждого элемента массива необходимо найти индекс ближайшего элемента справа, который меньше текущего. Если такого элемента нет, следует вернуть Х.

### Идея решения
Алгоритм использует стек для хранения элементов, для которых еще не найден ближайший меньший справа. Основные принципы:
1. Проход по массиву слева направо
2. Для каждого текущего элемента:
   - Пока вершина стека больше текущего элемента, извлекаем элементы из стека (текущий элемент является для них ответом)
   - Добавляем текущий элемент в стек
3. В стеке всегда поддерживается возрастающая последовательность

### Реализация
```cpp
#include <iostream>
#include <vector>
#include <stack>

using namespace std;

vector<int> nearestSmallerRight(const vector<int>& nums) {
    int n = nums.size();
    vector<int> result(n, -1);
    stack<pair<int, int>> st;
    
    for (int i = 0; i < n; ++i) {
        while (!st.empty() && st.top().first > nums[i]) {
            result[st.top().second] = i;
            st.pop();
        }
        st.push({nums[i], i});
    }
    return result;
}
```

## Практическая часть

### Тестирование программы

**Тест 1**(из разбора): <br><br>
![Первый тест](https://github.com/BoT-TEMA/add/blob/main/Screenshot%202025-06-04%20at%2023.54.39.png)
```
Индексы:   0  1  2  3  4  5  6  7  8  9
Значения:  7  2  4  5  3  2  5  1  5  4
Результат: 1  5  4  4  5  7  7 -1  9 -1
```

**Тест 2**: Входные данные: `1 2 3 4 5`
```
Индексы:   0  1  2  3  4
Значения:  1  2  3  4  5
Результат: -1 -1 -1 -1 -1
```

**Тест 3**: Входные данные: `5 4 3 2 1`
```
Индексы:   0  1  2  3  4
Значения:  5  4  3  2  1
Результат: 1  2  3  4 -1
```

**Тест 4**: Входные данные: `3 1 4 1 5 9 2 6`
```
Индексы:   0  1  2  3  4  5  6  7
Значения:  3  1  4  1  5  9  2  6
Результат: 1  3  3 -1  6  6 -1 -1
```

### Анализ результатов
Во всех тестах программа корректно находит индексы ближайших меньших элементов справа. В случаях, когда такого элемента нет (последний элемент или элементы в возрастающем порядке), возвращается -1.

## Выводы

1. Алгоритм успешно решает задачу поиска ближайшего меньшего справа за O(n) времени и O(n) дополнительной памяти
2. Реализация соответствует подходу, разобранному в видео-разборе задачи
3. Тестирование подтвердило корректность работы алгоритма для различных случаев:
   - Убывающие последовательности
   - Возрастающие последовательности
   - Случайные последовательности
   - Последовательности с повторяющимися элементами

Программа демонстрирует эффективное решение задачи с использованием стека, что позволяет достичь линейной временной сложности.
